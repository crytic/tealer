"""Create functions for a Teal contract.

Teal contract with N subroutines is represented using `N + 1` disconnected CFGs. Each subroutine
has its own CFG and the code which is not part of any subroutine is represented using a separate CFG, referred to
as __main__ CFG. The entry block of the __main__ CFG is the entry block of the contract. Execution of the contract
always starts here. Each of the CFG, including the __main__ CFG, is represented using a Subroutine class.

Every contract has abstract divison of function. A function represents an user operation: whenever a contract is executed,
the execution always results in execution of one of the function. The main benefit of functions is the ability to perform
analysis of each function independently which gives more accurate results.

In general, the first thing executed in a contract is the method dispatcher, it passes the execution to the method/function's
entry block based on the method selector. The method dispatcher is often generated by the compiler(PyTeal) or the framework used(Beaker).
Some contracts also contain custom method dispatchers implemented by the developers. And some contracts would not contain any functions,
the entire contract is a single function.

The method dispatcher can be:
    - Compiler or the compilation framework generated
    - Custom method dispatcher.
    - No method dispatcher. Entire contract is a single function.

A Function can be represented using the function entry block. The body of the function is the code reachable from that entry
block. The Function class could just store the entry block and analyze the function using that. However, the contracts with
custom dispatchers might contain the function body as part of its method dispatcher. For example, the dispatcher
could contain validations, variable assignments that are common for multiple functions in it. In order to represent these functions,
Tealer replaces basic blocks that are part of the dispatcher but not part of the function with basic blocks that contain the
error instruction. As a result, the function code that is part of the dispatcher can also be analyzed.

The entry block of a function for contracts with compiler generated method dispatcher is not in the middle of a subroutine.
In practice, the custom method dispatcher also does not have entry block in the middle of the subroutine. It
is possible to implement to the method dispatcher such that some blocks of a subroutine are part of one function and
other blocks are part of another function. However, it is not common in practice.

Tealer assumes the custom method dispatcher does not have a function with entry block in the middle of the subroutine. Main reason
for this assumption is to simplify the design. __main__ CFG is disconnected from other CFGs and if the method dispatcher is only part
of this CFG, it is easy to divide and create copies of the __main__ CFG for each function and keep a single copy of
subroutines CFG.

With M functions and N subroutines, the Teal contract will be represented with `N + M + 1` CFGs: M functions + N subroutines and __main__
CFG. 

For functions whose dispatcher contains function body, all blocks from contract entry block to the function entry block will be
preserved and blocks that are part of the dispatcher and not part of the function will be replaced by custom Err instruction.

Functions whose dispatcher does not contain function body, blocks part of the dispatcher will not be preserved.

Construction of Functions:

Inputs: contract(Teal), user configuration(UserConfig).
    
    UserConfig.has_functions(bool): True if the contract has more than one function otherwise False
    UserConfig.identified_functions(bool): True if the functions are already identified and if Tealer does not have to use heuristics to
        identify them, otherwise False. If False, Tealer tries to identify the dispatcher and the functions.
    UserConfig.functions(List[Tuple[List[str], bool]]): List of functions. Each function is a Tuple of dispatcher_path(List[str]) and
        dispatcher_has_function_body(bool).
            - The dispatcher path is the list of basic block ids from the __main__ entry block id to the function
            entry block. 
            - The dispatcher_has_function_body is True when the dispatcher blocks contain validations, variable declarations, etc.. 

Output: List of functions of the contract (List[Function]).

Assumptions:
    - The entry block of a function is not part of a subroutine.

* if not UserConfig.has_functions:
    return copy of the __main__ CFG as Function.
* if not UserConfig.identified_functions:
    run heuristics and identify the dispatcher. returned value has same type as UserConfig.functions
* remove duplicates from the new functions and UserConfig.functions
* loop over the new functions and UserConfig.functions
    * if dispatcher_has_function_body:
        * Construct CFG with blocks form __main__ CFG entry to function entry block.
        * Replace unrelated dispatcher blocks with custom err instruction block.
    * else:
        * Construct a copy of __main__ CFG without the dispatcher blocks.
"""

from typing import TYPE_CHECKING

from tealer.teal.functions import Function

if TYPE_CHECKING:
    from tealer.teal.teal import Teal


class UserConfig:
    # temporary class. TODO: Move UserConfig related code to a separate module.
    pass


def construct_functions(teal: "Teal", user_config: "UserConfig") -> "Function":
    # intentionally not creating a copy for now. TODO: update the function.
    function = Function(teal.contract_name, teal.main.entry, teal.main.blocks, teal)
    return function
